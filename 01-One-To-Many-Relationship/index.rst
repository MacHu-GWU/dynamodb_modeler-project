One to Many Relationship in DynamoDB
==============================================================================


Overview
------------------------------------------------------------------------------
Amazon 当初把 Partition Key, Sort Key 作为 核心概念放在 DynamoDB 的设计中就是考虑到实际应用中 One to Many 是最常见的情况. 对于 NoSQL 而言, 不存在传统关系数据库模型中已经被数学严格证明过的范式. 对于一个需求通常有多重方案. 这些方案通常各有优劣, 没有哪个是最好的, 只有适不适合你的应用场景. 本文将详细的讨论 One to Many 的关系在 DynamoDB 中的实现, 以及各种方案的优缺点以及应用场景.


A Simple Example - Department and Employee
------------------------------------------------------------------------------
我们来考虑下面这个例子:

一个公司有很多 Department (部门) 和很多 Employee (员工). 每个 Employee 只属于一个 Department, 每个 Department 下可以有很多 Employee. 也就是说 Department 和 Employee 是 One to Many 的关系. 为了方便说明, 我们用 "One Entity" 指代会有许多其他 Entity 跟他相关的 Entity, 在这个例子中是 Department; 用 "Many Entity" 指代跟 "One Entity" 相关的 Entity, 在这个例子中是 Employee.

在实际企业项目中的情况往往比这个复杂. 一个 Entity 往往会跟多个 Entity 建立关系, 甚至同一对 Entity 之间就有几套关系. 例如每个 Employee 都有一个 Direct Manager (直系领导), 这个领导也是一个 Employee. 每个 Employee 都有一个 Mentor (导师), 这个 Mentor 也是一个 Employee. 这样就在 Employee 之间有两套 One to Many 的关系.

在这个例子里我们只讨论 Department 和 Employee 之间的关系. 先不考虑更复杂的情况.

Reference:

- Sample Data: https://docs.google.com/spreadsheets/d/1PG2YyBoH2NoPyhcGhweARX2XdbRlh8-EEH9YD4IidHU/edit#gid=460890669


How To Evaluate the Effectiveness of a Data Model
------------------------------------------------------------------------------
Data Model 是要为业务服务的. 在实际应用中, 跟 One to Many 相关的业务逻辑主要有下面 3 种:

1. 关联变更: 需要将每个 Many Entity 和一个 One Entity 关联起来. 这个关联关系可能会变化.
2. 查询多实体: 需要查询一个 One Entity 下的所有 Many Entity. 在我们这个例子中就是查询一个 department 下的所有 employee.
3. 查询单实体: 需要查询一个 Many Entity 所关联的 One Entity 的详细信息. 在我们这个例子中就是查询一个 employee 所在的 department.
4. 一个 Entity 有多个 O2M 关系: 有时候一个 Entity 和多个 Entity 之间都有 One to Many 的关系.


Method 1
------------------------------------------------------------------------------
在 ``department_id (pk)`` 里, department_id 是 field name, 括号里的是说明. pk 说明这个 field 是 partition key, sk 说明这个 field 是 sort key.

.. code-block::

    +---------------------------+--+-------------------------------------------+--+------------------------------------------+
    |     Table (department)    |  |              Table (employee)             |  |       GSI (deparment and employee)       |
    +--------------------+------+--+------------------+--------+---------------+--+-------------------+-------------+--------+
    | department_id (pk) | name |  | employee_id (pk) |  name  | department_id |  | deparment_id (pk) | employee_id |  name  |
    +--------------------+------+--+------------------+--------+---------------+--+-------------------+-------------+--------+
    |         d-1        |  HR  |  |        e-1       |  Alice |      d-1      |  |        d-1        |     e-1     |  Alice |
    +--------------------+------+--+------------------+--------+---------------+--+-------------------+-------------+--------+
    |         d-2        |      |  |        e-2       |   Bob  |      d-1      |  |        d-1        |     e-2     |   Bob  |
    +--------------------+------+--+------------------+--------+---------------+--+-------------------+-------------+--------+
    |                    |      |  |        e-3       |  Cathy |      d-2      |  |        d-2        |     e-3     |  Cathy |
    +--------------------+------+--+------------------+--------+---------------+--+-------------------+-------------+--------+
    |                    |      |  |        e-4       |  David |      d-2      |  |        d-2        |     e-4     |  David |
    +--------------------+------+--+------------------+--------+---------------+--+-------------------+-------------+--------+
    |                    |      |  |        e-5       | Edward |      d-2      |  |        d-2        |     e-5     | Edward |
    +--------------------+------+--+------------------+--------+---------------+--+-------------------+-------------+--------+

这种方式的核心是跟 Relational Database 的方式一样, 把 Entity 放在不同的表中, 并且数据已经被 Normalized 了. 在 Many Entity 的表中, 由于 DynamoDB 不支持对非 Key 的 field 进行 query, 所以我们需要把 department_id 作为 pk 放在一个 GSI 索引中来支持根据 department 查找所有的 employee.

1. **关联变更**: 容易, 修改 ``employee.department_id`` 既可.
2. **查询多实体**: 容易, 通过 GSI 查询. 并且能获得所有 employee 的详细信息.
3. **查询单实体**: 中等, 需要 2 次 get, 一次 get employee, 一次 get department 的详细信息.
4. **一个 Entity 有多个 O2M 关系**: 不好. 如果 employee 和其他 entity 也有 O2M 的关系, 你就需要增加一个 field 来跟 department 的关系区分开来, 并且要消耗一个 GSI. DynamoDB 只支持最多 20 个 GSI, 并且每增加一个 GSI 都会增加 DynamoDB 读写负担, 并且这个读写负担是要收费的.

Reference:

- Google Sheet: https://docs.google.com/spreadsheets/d/1PG2YyBoH2NoPyhcGhweARX2XdbRlh8-EEH9YD4IidHU/edit#gid=460890669


Method 2
------------------------------------------------------------------------------
.. code-block::

    +---------------------------+--+-------------------------------------------------------------+--+------------------------------------------------------------+
    |     Table (department)    |  |                       Table (employee)                      |  |                GSI (deparment and employee)                |
    +--------------------+------+--+------------------+--------+---------------+-----------------+--+-------------------+-------------+--------+-----------------+
    | department_id (pk) | name |  | employee_id (pk) |  name  | department_id | department_name |  | deparment_id (pk) | employee_id |  name  | department_name |
    +--------------------+------+--+------------------+--------+---------------+-----------------+--+-------------------+-------------+--------+-----------------+
    |         d-1        |  HR  |  |        e-1       |  Alice |      d-1      |        HR       |  |        d-1        |     e-1     |  Alice |        HR       |
    +--------------------+------+--+------------------+--------+---------------+-----------------+--+-------------------+-------------+--------+-----------------+
    |         d-2        |  IT  |  |        e-2       |   Bob  |      d-1      |        HR       |  |        d-1        |     e-2     |   Bob  |        HR       |
    +--------------------+------+--+------------------+--------+---------------+-----------------+--+-------------------+-------------+--------+-----------------+
    |                    |      |  |        e-3       |  Cathy |      d-2      |        IT       |  |        d-2        |     e-3     |  Cathy |        IT       |
    +--------------------+------+--+------------------+--------+---------------+-----------------+--+-------------------+-------------+--------+-----------------+
    |                    |      |  |        e-4       |  David |      d-2      |        IT       |  |        d-2        |     e-4     |  David |        IT       |
    +--------------------+------+--+------------------+--------+---------------+-----------------+--+-------------------+-------------+--------+-----------------+
    |                    |      |  |        e-5       | Edward |      d-2      |        IT       |  |        d-2        |     e-5     | Edward |        IT       |
    +--------------------+------+--+------------------+--------+---------------+-----------------+--+-------------------+-------------+--------+-----------------+

这种方式和 Method 1 一样. 唯一的区别是在 Employee 的表中包含了 Department 的全部信息. 也就是这是个 Denormalized 的设计. 其他没有区别. 这种设计可以通过一点信息冗余把 one entity 中重要的信息放到 many entity 那边, 节约一次查询 one entity 的动作. 例如查询 employee 的时候我们希望知道他的 department name 而不是 ID. 但是这样做在 department name 变化的时需要更新所有相关的 employee.

1. **关联变更**: 中等, 修改 ``employee.department_id`` 以及所有跟 department 相关的 field 既可. 由于是保存了 Department 的全部信息, 每当你更新 Department 的任何信息时, 你需要将所有相关的 Employee 也更新一遍. 当一个 Department 中的 Employee 很多时候会有很大的性能开销.
2. **查询多实体**: 容易, 通过 GSI 查询. 并且能获得 employee 的所有详细信息.
3. **查询单实体**: 容易, 一次 get employee 并且能获得 department 的所有详细信息.
4. **一个 Entity 有多个 O2M 关系**: 跟 Method 1 一样, 不好.

Reference:

- Google Sheet: https://docs.google.com/spreadsheets/d/1PG2YyBoH2NoPyhcGhweARX2XdbRlh8-EEH9YD4IidHU/edit#gid=181330012


Method 3
------------------------------------------------------------------------------
.. code-block::

    +-------------------------------------------------------------------------+--+-----------------------------------------------------------------------+
    |                              Table (entity)                             |  |                           GSI (relationship)			                          |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |  pk (partition_key)  |     sk(sort_key)     |       type       |  name  |  |  pk (partition_key)  |     sk(sort_key)     |       type       | name |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          d-1         |       __root__       |    department    |   HR   |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          d-2         |       __root__       |    department    |   IT   |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-1         |       __root__       |     employee     |  Alice |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-2         |       __root__       |     employee     |   Bob  |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-3         |       __root__       |     employee     |  Cathy |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-4         |       __root__       |     employee     |  David |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-5         |       __root__       |     employee     | Edward |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | d-1_d-e-relationship | e-1_d-e-relationship | d-e-relationship |        |  | e-1_d-e-relationship | d-1_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | d-1_d-e-relationship | e-2_d-e-relationship | d-e-relationship |        |  | e-2_d-e-relationship | d-1_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | d-2_d-e-relationship | e-3_d-e-relationship | d-e-relationship |        |  | e-3_d-e-relationship | d-2_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | d-2_d-e-relationship | e-4_d-e-relationship | d-e-relationship |        |  | e-4_d-e-relationship | d-2_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | d-2_d-e-relationship | e-5_d-e-relationship | d-e-relationship |        |  | e-5_d-e-relationship | d-2_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+

这种方式是 DynamoDB 的特色之一, 用一个表来存储所有的 Entity. 所有的 Entity 详细信息本身的 sk 是都是 ``__root__``. 然后把 relationship 作为一个 item 也保存在表中. 每一个 relationship 都有一个 type, 并且 item 的 pk, sk 分别是两个相关的 entity 的 pk 加上 type.

在这个表中, one-to-many 中的 one 一方 (也就是 department, 一个 department 可以有很多个 employee) 被放在了 pk.

1. **关联变更**: 容易, 由于关系信息是单独保存的, 所以关联变更本质上是一个 Delete 和一个 Create, 需要用 Transaction 来保证数据一致性. 不过数据关系的修改频率一般并不高, 这不是问题.
2. **查询多实体 (查询一个 department 下的所有 employee)**: 容易, ``query(pk="${department_id}_d-e-relationship")``. 如需获得 employee 的详细信息, 需要 1 个 Batch Get query.
3. **查询单实体 (查询一个 employee 所在的 department)**: 容易, ``query_gis(pk="${employee_id}_d-e-relationship")``. 如需获得 department 的详细信息, 需要 1 次 GIS query, 1 次 get department.
4. **一个 Entity 有多个 O2M 关系**: 由于用于描述关系的 item 要加上 ``d-e-relationship`` 后缀, 所以不同的关系之间不会有冲突. 随着关系的增加, 既没有增加新的 Field, 也没有用到 GSI, 而 DynamoDB 的水平扩展性超级强, 所以这种方式是最好的.

Reference:

- Google Sheet: https://docs.google.com/spreadsheets/d/1PG2YyBoH2NoPyhcGhweARX2XdbRlh8-EEH9YD4IidHU/edit#gid=1356563532


Method 4 (Recommend)
------------------------------------------------------------------------------
.. code-block::

    +-------------------------------------------------------------------------+--+-----------------------------------------------------------------------+
    |                              Table (entity)                             |  |                           GSI (relationship)			                          |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |  pk (partition_key)  |     sk(sort_key)     |       type       |  name  |  |  pk (partition_key)  |     sk(sort_key)     |       type       | name |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          d-1         |       __root__       |    department    |   HR   |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          d-2         |       __root__       |    department    |   IT   |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-1         |       __root__       |     employee     |  Alice |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-2         |       __root__       |     employee     |   Bob  |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-3         |       __root__       |     employee     |  Cathy |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-4         |       __root__       |     employee     |  David |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    |          e-5         |       __root__       |     employee     | Edward |  |                      |                      |                  |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | e-1_d-e-relationship | d-1_d-e-relationship | d-e-relationship |        |  | d-1_d-e-relationship | e-1_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | e-2_d-e-relationship | d-1_d-e-relationship | d-e-relationship |        |  | d-1_d-e-relationship | e-2_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | e-3_d-e-relationship | d-2_d-e-relationship | d-e-relationship |        |  | d-2_d-e-relationship | e-3_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | e-4_d-e-relationship | d-2_d-e-relationship | d-e-relationship |        |  | d-2_d-e-relationship | e-4_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+
    | e-5_d-e-relationship | d-2_d-e-relationship | d-e-relationship |        |  | d-2_d-e-relationship | e-5_d-e-relationship | d-e-relationship |      |
    +----------------------+----------------------+------------------+--------+--+----------------------+----------------------+------------------+------+

这种方式和 Method 3 一样. 唯一的区别是 one-to-many 中的 many 一方 (也就是 employee, 一个 department 可以有很多个 employee) 被放在了 pk. 和 Method 3 相比没有本质区别, 因为两种方法都需要 GIS. 而且两种查询必然一个走主表, 一个走 GIS. 不过这种方法跟关系数据库中的模型更相似, 更符合直觉.

1. **关联变更**: 容易, 和 Method 3 一样.
2. **查询多实体 (查询一个 department 下的所有 employee)**: 容易, ``query_gis(pk="${department_id}_d-e-relationship")``. 和 Method 3 一样, 如需获得 employee 的详细信息, 需要 1 个 Batch Get query.
3. **查询单实体 (查询一个 employee 所在的 department)**: 容易, ``query(pk="${employee_id}_d-e-relationship")``. 和 Method 3 一样, 如需获得 department 的详细信息, 需要 1 次 GIS query, 1 次 get department.
4. **一个 Entity 有多个 O2M 关系**: 和 Method 3 一样, 可以无限扩展.

Reference:

- Google Sheet: https://docs.google.com/spreadsheets/d/1PG2YyBoH2NoPyhcGhweARX2XdbRlh8-EEH9YD4IidHU/edit#gid=919477347


Reference
------------------------------------------------------------------------------
- `Google Sheet <https://docs.google.com/spreadsheets/d/1PG2YyBoH2NoPyhcGhweARX2XdbRlh8-EEH9YD4IidHU/edit#gid=460890669>`_
